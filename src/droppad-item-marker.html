<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="droppad-selector.html">
<link rel="import" href="droppad-canvas-canvas.html">

<dom-module id="droppad-item-marker">
  <template>
    <style>
      :host {
        display: block;
      }

      div {
        position: absolute;
      }

      #marker {
        box-sizing: border-box;
        top: 0;
        left: 0;
        margin: -20px;
        border: 1px dotted grey;
      }

      #marker div {
        z-index: 10000;
      }

      .scale {
        width: 6px;
        height: 6px;
        background-color: lightgrey;
        border: 1px solid grey;
      }

      #nw {
        top: -4px;
        left: -4px;
      }

      #ne {
        top: -4px;
        right: -4px;
      }

      #sw {
        bottom: -4px;
        left: -4px;
      }

      #se {
        bottom: -4px;
        right: -4px;
      }

      #w {
        top: calc(50% - 4px);
        left: -4px;
        border-radius: 50% 0 0 50%;
      }

      #e {
        top: calc(50% - 4px);
        right: -4px;
        border-radius: 0 50% 50% 0;
      }

      #s {
        bottom: -4px;
        left: calc(50% - 4px);
        border-radius: 0 0 50% 50%;
      }

      #n {
        top: -4px;
        left: calc(50% - 4px);
        border-radius: 50% 50% 0 0;
      }

      #marker #move {
        top: calc(50% - 6px);
        left: calc(50% - 6px);
        width: 12px;
        height: 12px;
        transform: rotate(45deg);
        background: url(../images/move.png);
        background-size: contain;
      }

      #marker #rotate {
        top: -20px;
        right: -20px;
        width: 16px;
        height: 16px;
        background: url(../images/rotate.png);
        background-size: contain;
      }

      #ne:hover {
        cursor: nesw-resize;
      }

      #sw:hover {
        cursor: nesw-resize;
      }

      #nw:hover {
        cursor: nwse-resize;
      }

      #se:hover {
        cursor: nwse-resize;
      }

      #e:hover {
        cursor: ew-resize;
      }

      #w:hover {
        cursor: ew-resize;
      }

      #n:hover {
        cursor: ns-resize;
      }

      #s:hover {
        cursor: ns-resize;
      }

      #rotate:hover {
        cursor: ns-resize;
      }

      #move:hover {
        cursor: move;
      }

      #marker:hover {
        cursor: move;
      }

      .help {
        display: none;
        top: -80px;
        left: -40px;
        font-size: 10px;
        width: 180px;
        height: 10px;
        background: rgba(0, 0, 0, 0.3);
        border: none;
        border-radius: 20px;
        padding: 15px;
        line-height: 10px;
        color: white;
        font-weight: bold;
      }

      #marker .corner:hover ~ #cornerhelp {
        display: block;
      }
    </style>
    <div id="marker" hidden$="[[!groupOfShapes.show]]"
         style$="left: [[groupOfShapes.left]]px; top: [[groupOfShapes.top]]px; width:  [[groupOfShapes.width]]px; height: [[groupOfShapes.height]]px;">
      <div id="nw" class="scale corner"></div>
      <div id="ne" class="scale corner"></div>
      <div id="sw" class="scale corner"></div>
      <div id="se" class="scale corner"></div>
      <div id="w" class="scale"></div>
      <div id="n" class="scale"></div>
      <div id="s" class="scale"></div>
      <div id="e" class="scale"></div>
      <div id="move"></div>
      <div id="rotate"></div>

      <div id="cornerhelp" class="help">Hold "shift" to scale symmetrically.</div>
      <!--<div id="rotatehelp" class="help">Hold "shift" to snap to nearest 30 deg.</div>-->
      <!--<div id="rotatehelp" class="help">Hold "shift" to rotate the elements individually.</div>-->
    </div>
    <template is="dom-if" if="[[!groupOfShapes.show]]">
      <template is="dom-repeat" items="[[groupOfShapes.infos]]">
        <drop-shape id="copy[[item.number]]" class="copy" info="[[item]]"></drop-shape>
      </template>
    </template>
  </template>

  <script>
    class GroupOfShapes {

      constructor(infos, factor) {
        this._calcDimensions(infos, factor);
        this.show = true;
      }

      _calcDimensions(infos, factor) {
        for (let info of infos)
          this._addDimension(info.getBoundingRect(factor));
        this.width = this.right - this.left;
        this.height = this.bottom - this.top;
      }

      _addDimension(next) {
        this.left = Math.min(this.left || Number.MAX_VALUE, next.left);
        this.top = Math.min(this.top || Number.MAX_VALUE, next.top);
        this.right = Math.max(this.right || -Number.MAX_VALUE, next.right);
        this.bottom = Math.max(this.bottom || -Number.MAX_VALUE, next.bottom);
      }

      start(action, infos) {
        this.originals = infos;
        this.infos = this.originals.map(info => info.clone());
        this.show = false;
        this.action = action;
      }

      move(e, xMove, yMove, angle) {
        this.xMove = xMove;
        this.yMove = yMove;
        this.percentX = this.xMove / this.width;
        this.percentY = this.yMove / this.height;
        this.angleMove = angle;
        this.infos = this.runAction();
      }

      getPercentOfHeight(info) {
        return info.height / this.height;
      }

      getPercentOfWidth(info) {
        return info.width / this.width;
      }

      getDistanceFromLeft(info) {
        return (info.x - this.left);
      }

      getDistanceFromRight(info) {
        return (this.right - info.x );
      }

      getDistanceFromTop(info) {
        return (this.top - info.y);
      }

      getDistanceFromBottom(info) {
        return (info.y - this.bottom);
      }

      runAction() {
        let clones = this.originals.map(info => info.clone());
        switch (this.action.method) {
          case "scale":
            return clones.map(function (info) {
                info.scaleDirection(
                  this.percentX,
                  this.percentY,
                  this.getDistanceFromTop(info),
                  this.getDistanceFromRight(info),
                  this.getDistanceFromBottom(info),
                  this.getDistanceFromLeft(info),
                  this.action.direction
                );
                return info;
              }.bind(this)
            );
          case "rotate":
            return clones.map(function (info) {
              info.rotate(this.angleMove);
              return info;
            }.bind(this));
          case "move":
            return clones.map(function (info) {
              info.move(this.xMove, this.yMove);
              return info;
            }.bind(this));
        }
      }
    }

    class DroppadItemMarker extends Polymer.Element {
      static get is() {
        return "droppad-item-marker";
      }

      static get config() {
        return {
          properties: {
            items: Array,
            groupOfShapes: {
              type: GroupOfShapes,
              computed: "_itemsChanged(items)"
            },
            heldkeys: Array,
            p2p: PointToPoint
          }
        }
      }

      //todo fix the rotation of groups of elements.
      //todo move over the copy and paste functionality
      _itemsChanged(items) {
        return items && items.length ? new GroupOfShapes(items.map(el => el.info), 40) : null;
      }

      connectedCallback() {
        this.$.marker.addEventListener("pointerdown", this._pointerDown.bind(this));
        this.pointermoveListener = this._pointerMove.bind(this);
        this.pointerupListener = this._pointerUp.bind(this);
      }

      _pointerDown(e) {
        this.addEventListener("pointermove", this.pointermoveListener);
        this.addEventListener("pointerup", this.pointerupListener);
        this.setPointerCapture(e.pointerId);
        DroppadItemMarker._cancelPropDefault(e);
        let action = this.setMoveAction(e, this.heldKeys);
        this.markerCenterScreen = DroppadItemMarker.getScreenCenter(this.$.marker);
        this.startEvent = e;
        this.startAngle = DroppadItemMarker.calcAngle(this.markerCenterScreen, {x: e.clientX, y: e.clientY});
        this.groupOfShapes.start(action, this.items.map(el => el.info));

        this.notifyPath("groupOfShapes");
      }

      _pointerUp(e) {
        this.dispatchEvent(new CustomEvent("changed", {detail: this.groupOfShapes.infos}));
        this.releasePointerCapture(e.pointerId);
        this.removeEventListener("pointerup", this.pointerupListener);
        this.removeEventListener("pointermove", this.pointermoveListener);
        DroppadItemMarker._cancelPropDefault(e);
        setTimeout(function () {
          this.notifyPath("items");
        }.bind(this), 0);
        //att! The setTimout(func, 0) makes the notifyPath("items") wait until Polymer has updated the selected items so that
        //     the groupOfShapes and its bounding box is updated with the new position info, and not the current one in the objects..
        //     This is a cascading problem..
      }

      _pointerMove(e) {
        DroppadItemMarker._cancelPropDefault(e);
        let xMove = this.p2p.calcLogicalDistance(e.clientX, this.startEvent.clientX);
        let yMove = this.p2p.calcLogicalDistance(e.clientY, this.startEvent.clientY);
        let angle = DroppadItemMarker.calcAngle(this.markerCenterScreen, {x: e.clientX, y: e.clientY});
        //snap  start
        if (Math.abs(xMove) < 6 && Math.abs(yMove) < 6)
          xMove = yMove = 0;
        else if (this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"])
          xMove = yMove;
        //snap  end
        this.groupOfShapes.move(e, xMove, yMove, angle);
        this.notifyPath("groupOfShapes");
      }

      static _cancelPropDefault(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      setMoveAction(e, heldKeys) {
        let direction = e.target.id;
        let action = "move"; //default action is move
        if (e.target.classList.contains("scale") || heldKeys["KeyE"])
          action = "scale";
        else if (e.target.id == "rotate" || heldKeys["KeyR"])
          action = "rotate";
        else if (e.target.id == "move")
          action = "move";
        return {method: action, direction: direction};
      }

      static getScreenCenter(elem) {
        const box = elem.getBoundingClientRect();
        return {x: box.left + box.width / 2, y: box.top + box.height / 2};
      }

      static calcAngle(c, p1) {
        let p0 = {x: c.x, y: -1};
        let p0c = Math.sqrt(Math.pow(c.x - p0.x, 2) +
          Math.pow(c.y - p0.y, 2)); // p0->c (b)
        let p1c = Math.sqrt(Math.pow(c.x - p1.x, 2) +
          Math.pow(c.y - p1.y, 2)); // p1->c (a)
        let p0p1 = Math.sqrt(Math.pow(p1.x - p0.x, 2) +
          Math.pow(p1.y - p0.y, 2)); // p0->p1 (c)
        let number = Math.acos((p1c * p1c + p0c * p0c - p0p1 * p0p1) / (2 * p1c * p0c));
        if (p1.x < c.x)
          number= 2*Math.PI-number;
        return number;
      }
    }
    customElements.define(DroppadItemMarker.is, DroppadItemMarker);
  </script>
</dom-module>