<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="droppad-selector.html">
<link rel="import" href="droppad-canvas-canvas.html">
<link rel="import" href="selected-observer.html">
<link rel="import" href="item-marker.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }

      drop-shape[data-selected] {
        box-shadow: 0 0 3px 0px black;
      }

    </style>
    <droppad-canvas-canvas id="canvas" p2p="{{p2p}}" on-dbltap="_newShape" on-singletap="_deselectAll">
      <droppad-selector id="dropSelector">
        <template is="dom-repeat" items="[[drops]]">
          <drop-shape id="drop[[item.number]]" info="[[item]]" data-selectable></drop-shape>
        </template>
      </droppad-selector>
      <selected-observer p2p="[[p2p]]" box="{{selecteds}}"></selected-observer>
      <item-marker id="square" p2p="[[p2p]]" held-keys="[[heldKeys]]" box="[[selecteds]]"
                           on-track-start="_startMovingMarker"
                           on-track-move="_movingMarker"
                           on-track-end="_stopMovingMarker"></item-marker>
      <group-of-shapes id="ghost" class="copy"></group-of-shapes>
      <group-of-shapes id="ghostCopy"></group-of-shapes>
      <group-of-shapes id="historyPreview"></group-of-shapes>
    </droppad-canvas-canvas>
  </template>

  <script>
    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            drops: Array,
            heldKeys: Array,
            _pointerMove: Event
          }
        }
      }

      connectedCallback() {
        this.addEventListener("pointermove", function(e){this._pointerMove = e;}.bind(this));
      }

      _startMovingMarker(e) {
        this.$.ghost.start(this.getSelectedInfos());
        this.dispatchEvent(new CustomEvent("help-on", {detail: e.detail}));
      }

      getSelectedInfos() {
        if (!this.drops)
          return [];
        const numbers = [];
        for (let el of this.$.dropSelector.querySelectorAll("drop-shape[data-selected]"))
          numbers.push(el.info.number);
        return this.drops.filter(info => numbers.indexOf(info.number) != -1);
      }

      _movingMarker(e) {
        let ms = e.detail;
        switch (ms.action) {
          case "scale":
            return this.$.ghost.scaleDirection(ms.percentX, ms.percentY, ms.direction, ms.box);
          case "rotate":
            return this.$.ghost.rotate(ms.angle, ms.box);
          case "move":
            return this.$.ghost.move(ms.xMove, ms.yMove);
        }
      }

      _stopMovingMarker(e) {
        this.action = null;
        this.replaceChanges(this.$.ghost.end());
        this.dispatchEvent(new CustomEvent("help-off"));
      }

      copy() {
        this.copyData = this.getSelectedInfos().map(info => info.makeCopy());
        this.copyCenter = this.$.square.getLogicalCenter();
      }

      paste() {
        this.$.ghostCopy.start(this.copyData);
        this.copyData = this.copyData.map(info => info.makeCopy());//todo need to do this if we paste more than once from the same copy
        const logicPointPos = this.p2p.calcLogicPoint(this._pointerMove.clientX, this._pointerMove.clientY);
        this.$.ghostCopy.move(logicPointPos.x-this.copyCenter.x, logicPointPos.y -this.copyCenter.y);
        let shapes = this.$.ghostCopy.end();
        this.dispatchEvent(new CustomEvent("addshapes", {detail: shapes}));
        this.$.dropSelector.deselectAll();
        this.selectDelayed(shapes);
      }

      handleKeyPress(e) {
        if (e.code === "Escape")
          this.$.dropSelector.deselectAll(); // also do this.$.square.abort();
        else if (e.code === "Digit0" && this.holdsCtrl())
          this.$.canvas.reset();
        else if (e.code === "KeyD")
          this._deleteElem();
        else if (e.code === "KeyC" && this.holdsCtrl())
          this.copy();
        else if (e.code === "KeyV" && this.holdsCtrl())
          this.paste();
        else if (e.code == "KeyM")
          this.replaceChanges(this.getSelectedInfos().map(info => info.mirror()));
        else if (e.code == "KeyN")
          this.replaceChanges(this.getSelectedInfos().map(info => info.center()));
        else if (e.code == "PageUp")
          this.replaceChanges(this.getSelectedInfos().map(info => info.zUp()));
        else if (e.code == "PageDown")
          this.replaceChanges(this.getSelectedInfos().map(info => info.zDown()));
      }

      holdsCtrl() {
        return this.heldKeys["ControlLeft"] || this.heldKeys["ControlRight"];
      }

      timeTravel(historicState) {
        if (historicState){
          this.$.dropSelector.style.opacity = 0.2;
          this.$.historyPreview.start(historicState);
        } else {
          this.$.dropSelector.style.opacity = 1;
          this.$.historyPreview.end();
        }
      }

      addStyleToSelected(styleName) {
        this.replaceChanges(this.getSelectedInfos().map(info => info.setStyle(styleName)));
      }

      updateShape(id, value) {
        this.$.dropSelector.deselectAll();
        this.select(id);
        this.replaceChanges(this.getSelectedInfos().map(el => el.update(value)));
      }

      select(id) {
        this.$.dropSelector.select(this.shadowRoot.querySelector("#drop" + id));
      }

      _deselectAll() {
        this.$.dropSelector.deselectAll();
      }

      _newShape(e) {
        let shapes = [new ShapeInfoObject(e.detail.x, e.detail.y)];
        this.dispatchEvent(new CustomEvent("addshapes", {detail: shapes}));
        if (!e.shiftKey)
          this.$.dropSelector.deselectAll();
        this.selectDelayed(shapes);
      }

      //must wait for the element to appear in the dom.
      selectDelayed(shapes) {
        setTimeout(function () {
          for (let shape of shapes)
            this.$.dropSelector.select(this.shadowRoot.querySelector("#drop" + shape.number));
        }.bind(this), 0);
      }

      replaceChanges(changedCopies) {
        this.dispatchEvent(new CustomEvent("changeshapes", {detail: changedCopies}));
      }

      _deleteElem() {
        this.dispatchEvent(new CustomEvent("removeshapes", {detail: this.getSelectedInfos()}));
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>