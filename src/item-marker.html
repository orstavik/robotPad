<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="group-of-shapes.html">

<dom-module id="item-marker">
  <template>
    <style>
      :host {
        display: block;
      }
      div {
        position: absolute;
      }
      #marker {
        position: absolute;
        box-sizing: border-box;
        top: 0;
        left: 0;
        border: 1px dotted grey;
      }
      #marker div {
        z-index: 10000;
      }
      .scale {
        width: 6px;
        height: 6px;
        background-color: lightgrey;
        border: 1px solid grey;
      }
      #nw {
        top: -4px;
        left: -4px;
      }
      #ne {
        top: -4px;
        right: -4px;
      }
      #sw {
        bottom: -4px;
        left: -4px;
      }
      #se {
        bottom: -4px;
        right: -4px;
      }
      #w {
        top: calc(50% - 4px);
        left: -4px;
        border-radius: 50% 0 0 50%;
      }
      #e {
        top: calc(50% - 4px);
        right: -4px;
        border-radius: 0 50% 50% 0;
      }
      #s {
        bottom: -4px;
        left: calc(50% - 4px);
        border-radius: 0 0 50% 50%;
      }
      #n {
        top: -4px;
        left: calc(50% - 4px);
        border-radius: 50% 50% 0 0;
      }
      #marker #move {
        bottom: -16px;
        right: -16px;
        width: 12px;
        height: 12px;
        transform: rotate(45deg);
        background: url(../images/move.png);
        background-size: contain;
      }
      #marker #rotate {
        top: -20px;
        right: -20px;
        width: 16px;
        height: 16px;
        background: url(../images/rotate.png);
        background-size: contain;
      }
      #ne:hover { cursor: nesw-resize; }
      #sw:hover { cursor: nesw-resize; }
      #nw:hover { cursor: nwse-resize; }
      #se:hover { cursor: nwse-resize; }
      #e:hover { cursor: ew-resize; }
      #w:hover { cursor: ew-resize; }
      #n:hover { cursor: ns-resize; }
      #s:hover { cursor: ns-resize; }
      #rotate:hover { cursor: ns-resize; }
      #move:hover { cursor: move; }
      #marker:hover { cursor: move; }
    </style>
    <div id="marker" hidden$="[[!box]]" style$="
         left: [[box.left]]px;
         top: [[box.top]]px;
         width:  [[box.width]]px;
         height: [[box.height]]px;
         [[matrixString]]">
      <div id="nw" class="scale corner"></div>
      <div id="ne" class="scale corner"></div>
      <div id="sw" class="scale corner"></div>
      <div id="se" class="scale corner"></div>
      <div id="w" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="n" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="s" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="e" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="move"></div>
      <div id="rotate"></div>
    </div>
  </template>

  <script>

    class MatrixChange {
      static doStartSnap(point, start) {
        let nearStartingPoint = Math.abs(start.x - point.x) < 6 && Math.abs(start.y - point.y) < 6;
        return nearStartingPoint ? start : point;
      }

      static multiMatrixTom(A, B) {
        A = [
          [A[0], A[2], A[4]],
          [A[1], A[3], A[5]],
          [0, 0, 1]
        ];
        B = [
          [B[0], B[2], B[4]],
          [B[1], B[3], B[5]],
          [0, 0, 1]
        ];
        const arr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        for (let ai = 0; ai < A.length; ai++) {
          for (let bj = 0; bj < B[0].length; bj++) {
            for (let aj = 0; aj < A[0].length; aj++) {
              for (let bi = 0; bi < B.length; bi++) {
                if (aj === bi) {
                  arr[ai][bj] += A[ai][aj] * B[bi][bj];
                }
              }
            }
          }
        }
        return [arr[0][0], arr[1][0], arr[0][1], arr[1][1], arr[0][2], arr[1][2]];
      }
    }

    class RotateChange {
      constructor(startPoint, center) {
        this.start = startPoint;        //don't really need
        this.center = center;
        this.startAngle = RotateChange.calcAngle(this.center, startPoint);
        this.action = "rotate";
        this.angle = 0;
      }

      static calcAngle(center, satelite) {
        return Math.atan2(satelite.y - center.y, satelite.x - center.x);
      }

      change(newPoint, shift) {
        newPoint = MatrixChange.doStartSnap(newPoint, this.start);
//        if (shiftIsDown)
//          rad = this.currentAngle?
//        if (ctrlIsDown)
//          rad = this.angle snap to nearest 30degree?
        this.currentAngle = RotateChange.calcAngle(this.center, newPoint);
        this.angle = this.currentAngle - this.startAngle;
      }

      getMatrix() {
        return RotateChange.toMatrix(this.angle);
      }

      static toMatrix(rad) {
        return [
          Math.cos(rad),
          Math.sin(rad),
          -Math.sin(rad),
          Math.cos(rad),
          0,
          0
        ];
      }

      subdueMatrix(matrix) {
        return MatrixChange.multiMatrixTom(this.getMatrix(), matrix);
      }
    }

    class MoveChange {
      constructor(startPoint) {
        this.start = startPoint;
        this.action = "move";
        this.xMove = 0;
        this.yMove = 0;
      }

      change(newPoint, shift) {
        newPoint = MatrixChange.doStartSnap(newPoint, this.start);
//        if (shift)
//          this.yMove = 0;
//        if (ctrl)
//          this.xMove = 0;
        this.xMove = newPoint.x - this.start.x;
        this.yMove = newPoint.y - this.start.y;
      }

      getMatrix() {
        return [1, 0, 0, 1, this.xMove, this.yMove];
      }

      subdueMatrix(matrix) {
        return MatrixChange.multiMatrixTom(this.getMatrix(), matrix);
      }
    }

    class ScaleChange {
      constructor(startPoint, boxWidth, boxHeight, direction, box) {
        this.start = startPoint;
        this.boxWidth = boxWidth;
        this.boxHeight = boxHeight;
        this.action = "scale";
        this.direction = direction;
        this.box = box;
        this.percentX = 0;
        this.percentY = 0;
        this.xMove = 0;
        this.yMove = 0;
      }

      change(newPoint, shift) {
        newPoint = MatrixChange.doStartSnap(newPoint, this.start);
//        if (shift){
//          this.percentX = 0;
//          this.xMove = a little less or more?
//        }
//        if (ctrl){
//          this.percentY = 0;
//          this.yMove = a little less or more?
//        }

        let xMove = newPoint.x - this.start.x;
        let yMove = newPoint.y - this.start.y;

        if (this.direction.indexOf("n") < 0 && this.direction.indexOf("s") < 0)
          yMove = 0;
        if (this.direction.indexOf("e") < 0 && this.direction.indexOf("w") < 0)
          xMove = 0;

        this.percentX = xMove / this.boxWidth;
        this.percentY = yMove / this.boxHeight;
        this.yMove = this.percentY * this.boxHeight / 2;
        this.xMove = this.percentX * this.boxWidth / 2;
        if (this.direction.indexOf("n") >= 0)
          this.percentY *= -1;
        if (this.direction.indexOf("w") >= 0)
          this.percentX *= -1;
      }

      getMatrix() {
        return [
          1 + this.percentX,
          0,
          0,
          1 + this.percentY,
          this.xMove,
          this.yMove];
      }

      subdueMatrix(matrix) {
        return MatrixChange.multiMatrixTom(matrix, this.getMatrix());
      }
    }

    class ItemMarker extends Polymer.Element {
      static get is() {
        return "item-marker";
      }

      static get config() {
        return {
          properties: {
            p2p: PointToPoint,
            box: Object,
            change2: Object,
            matrix: {
              type: Array,
              computed: "_makeMatrix(change2, box)"
            },
            matrixString: {
              type: String,
              computed: "_matrixToString(matrix)"
            }
          }
        }
      }

      _matrixToString(matrix) {
        return matrix ? "transform: matrix(" + matrix.join(',') + ");" : "";
      }

      _makeMatrix(changes, box) {
        if (!changes && !box)
          return null;
        if (!box)
          return changes.getMatrix();
        if (!changes)
          return RotateChange.toMatrix(box.angle);
        return changes.subdueMatrix(RotateChange.toMatrix(box.angle));
      }

      connectedCallback() {
        this.$.marker.addEventListener("pointerdown", this._pointerDown.bind(this));
        this.pointermoveListener = this._pointerMove.bind(this);
        this.pointerupListener = this._pointerUp.bind(this);
      }

      _pointerDown(e) {
        ItemMarker._cancelPropDefault(e);
        this.setPointerCapture(e.pointerId);
        this.addEventListener("pointermove", this.pointermoveListener);
        this.addEventListener("pointerup", this.pointerupListener);
        let start = this.p2p.calcLogicPoint(e.clientX, e.clientY);
        let action = this.setMoveAction(e);
        let change = null;
        if (action == "rotate")
          change = new RotateChange(start, this.box.center, this.box);
        else if (action == "move")
          change = new MoveChange(start);
        else if (action == "scale")
          change = new ScaleChange(start, this.box.width, this.box.height, e.target.id, this.box);
        this.set("change2", change);
        this.dispatchEvent(new CustomEvent("track-start", {composed: true, bubbles: true, detail: action}));
      }

      _pointerMove(e) {
        ItemMarker._cancelPropDefault(e);
        this.change2.change(this.p2p.calcLogicPoint(e.clientX, e.clientY), this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"]);  //todo make heldKeys.shift()
        this.notifyPath("change2");
        this.dispatchEvent(new CustomEvent("track-move", {detail: this.change2, composed: true, bubbles: true}));
      }

      _pointerUp(e) {
        ItemMarker._cancelPropDefault(e);
        this.releasePointerCapture(e.pointerId);
        this.removeEventListener("pointerup", this.pointerupListener);
        this.removeEventListener("pointermove", this.pointermoveListener);
        this.dispatchEvent(new CustomEvent("track-end", {composed: true, bubbles: true}));
        this.set("change2", null);
      }

      static _cancelPropDefault(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      getLogicalCenter() {
        return this.box.center;
      }

      setMoveAction(e) {
        if (this.heldKeys["KeyR"] || e.target.id == "rotate")
          return "rotate";
        if (this.heldKeys["KeyE"] || e.target.classList.contains("scale"))
          return "scale";
        return "move";
      }
    }
    customElements.define(ItemMarker.is, ItemMarker);
  </script>
</dom-module>