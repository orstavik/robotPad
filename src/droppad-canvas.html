<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="droppad-selector.html">
<link rel="import" href="droppad-canvas-canvas.html">
<link rel="import" href="droppad-item-marker.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }

      drop-shape[data-selected] {
        box-shadow: 0 0 3px 0px black;
      }

    </style>
    <droppad-canvas-canvas center="{{position}}" zoom="{{zoom}}" on-new-shape="_newShape" on-deselect="_deselectAll">
      <droppad-selector id="dropSelector" selected-elements="{{selectedDrops}}">
        <template is="dom-repeat" items="[[drops]]">
          <drop-shape id="drop[[item.number]]" info="[[item]]"></drop-shape>
        </template>
      </droppad-selector>
      <droppad-item-marker id="square" items="[[selectedDrops]]"></droppad-item-marker>
    </droppad-canvas-canvas>
  </template>

  <script>
    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            drops: {
              type: Array,
              notify: true
            },
            selectedDrops: {
              type: Array,
              notify: true
            },
            selectedIds: {
              type: Array,
              notify: true,
              computed: "_setSelectedIds(selectedDrops)"
            },
            heldKeys: Array,
            history: {
              type: Array,
              value: function () {
                return [];
              },
              notify: true
            }
          }
        }
      }

      _setSelectedIds(elems) {
        return elems.map(item => item.info.number);
      }

      connectedCallback() {
//        this.addEventListener("click", this._mouseDown.bind(this));
        window.addEventListener("keydown", this._registerKey.bind(this));
        this.mouseMoveListener = this.mouseMove.bind(this);
        window.addEventListener("mousemove", this.mouseMoveListener);
        ImmutableArrayFunctions.testSpeed(100000);
      }

      _registerKey(e) {
        if (e.code === "Escape")
          this.$.dropSelector.deselectAll();
        if (e.code === "Digit0" && e.ctrlKey)
          this.zoom = 1;
        else if (e.code === "KeyD") {
          this._deleteElem();
          this.$.dropSelector.deselectAll();
        } else if (e.code === "KeyC")
          this.copiedShapes = this.selectedDrops.slice();
        else if (e.code === "KeyV") {
          for (let i = 0; i < this.copiedShapes.length; i++) {
            this._addElem(this.copiedShapes[i].info.makeCopy(this.position.x, this.position.y));
          }
        }
        else if (e.code == "KeyM")
          this.alterSelected(ShapeInfoObject.prototype.mirror);
        else if (e.code == "KeyN")
          this.alterSelected(ShapeInfoObject.prototype.center);
        else if (e.code == "PageUp")
          this.alterSelected(ShapeInfoObject.prototype.zUp);
        else if (e.code == "PageDown")
          this.alterSelected(ShapeInfoObject.prototype.zDown);
      }

      mouseMove(e) {
        if (e.which != 1)
          return;
        if (!this.selectedIds)
          return;
//        if (e.path[0] == this) //todo make the listener only work when you hold the mouse over a selected item.
//          return;              //todo Stops working the minute the mouse pointer moves out of the drop.
        let yMove = e.movementY / this.zoom; //todo, this conversion is necessary for move, and maybe scaleFree in the future.
        let xMove = e.movementX / this.zoom;
        if (this.heldKeys["KeyE"] && this.heldKeys["KeyW"])
          this.alterSelected(ShapeInfoObject.prototype.scaleRestrict, yMove);
        else if (this.heldKeys["KeyE"] && this.heldKeys["KeyR"])
          this.alterSelected(ShapeInfoObject.prototype.scaleSquare, yMove);
        else if (this.heldKeys["KeyE"])
          this.alterSelected(ShapeInfoObject.prototype.scaleFree, xMove, yMove);
        else if (this.heldKeys["KeyR"])
          this.alterSelected(ShapeInfoObject.prototype.rotate, yMove);
        else
          this.alterSelected(ShapeInfoObject.prototype.move, xMove, yMove);
      }

      addStyleToSelected(styleName) {
        this.alterSelected(ShapeInfoObject.prototype.setStyle, styleName);
      }

      updateShape(id, value) {
        this.$.dropSelector.deselectAll();
        this.select(id);
        this.alterSelected(ShapeInfoObject.prototype.update, value);
      }

      select(id) {
        this.$.dropSelector.select(this.shadowRoot.querySelector("#drop" + id));
      }

      _deselectAll() {
        this.$.dropSelector.deselectAll();
      }

      _newShape(e) {
        let shape = new ShapeInfoObject(e.detail.x, e.detail.y);
        this._addElem(shape);
        if (!e.shiftKey)
          this.$.dropSelector.deselectAll();
        setTimeout(function () {
          this.select(shape.number);
        }.bind(this), 0);
      }

      loadSketch(drops) {
        this.set("drops", drops);
      }

      alterSelected(func, arg1, arg2) {
        this.history.push(this.drops);
        this.$.dropSelector.abort();
        this.set("drops", ImmutableArrayFunctions.alter(this.drops, this.selectedIds, func, arg1, arg2));
      }

      _deleteElem() {
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.filter(this.drops, this.selectedIds));
      }

      _addElem(shapeInfoObj) {
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.push(this.drops, shapeInfoObj));
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>