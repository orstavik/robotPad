<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="group-of-shapes.html">

<dom-module id="droppad-item-marker">
  <template>
    <style>
      :host {
        display: block;
      }

      div {
        position: absolute;
      }

      #marker {
        box-sizing: border-box;
        top: 0;
        left: 0;
        margin: -20px;
        border: 1px dotted grey;
      }

      #marker div {
        z-index: 10000;
      }

      .scale {
        width: 6px;
        height: 6px;
        background-color: lightgrey;
        border: 1px solid grey;
      }

      #nw {
        top: -4px;
        left: -4px;
      }

      #ne {
        top: -4px;
        right: -4px;
      }

      #sw {
        bottom: -4px;
        left: -4px;
      }

      #se {
        bottom: -4px;
        right: -4px;
      }

      #w {
        top: calc(50% - 4px);
        left: -4px;
        border-radius: 50% 0 0 50%;
      }

      #e {
        top: calc(50% - 4px);
        right: -4px;
        border-radius: 0 50% 50% 0;
      }

      #s {
        bottom: -4px;
        left: calc(50% - 4px);
        border-radius: 0 0 50% 50%;
      }

      #n {
        top: -4px;
        left: calc(50% - 4px);
        border-radius: 50% 50% 0 0;
      }

      #marker #move {
        top: calc(50% - 6px);
        left: calc(50% - 6px);
        width: 12px;
        height: 12px;
        transform: rotate(45deg);
        background: url(../images/move.png);
        background-size: contain;
      }

      #marker #rotate {
        top: -20px;
        right: -20px;
        width: 16px;
        height: 16px;
        background: url(../images/rotate.png);
        background-size: contain;
      }

      #ne:hover {
        cursor: nesw-resize;
      }

      #sw:hover {
        cursor: nesw-resize;
      }

      #nw:hover {
        cursor: nwse-resize;
      }

      #se:hover {
        cursor: nwse-resize;
      }

      #e:hover {
        cursor: ew-resize;
      }

      #w:hover {
        cursor: ew-resize;
      }

      #n:hover {
        cursor: ns-resize;
      }

      #s:hover {
        cursor: ns-resize;
      }

      #rotate:hover {
        cursor: ns-resize;
      }

      #move:hover {
        cursor: move;
      }

      #marker:hover {
        cursor: move;
      }

      .help {
        display: none;
        top: -80px;
        left: -40px;
        font-size: 10px;
        width: 180px;
        height: 10px;
        background: rgba(0, 0, 0, 0.3);
        border: none;
        border-radius: 20px;
        padding: 15px;
        line-height: 10px;
        color: white;
        font-weight: bold;
      }

      #marker .corner:hover ~ #cornerhelp {
        display: block;
      }
    </style>
    <div id="marker" hidden$="[[!groupOfShapes.left]]"
         style$="left: [[groupOfShapes.left]]px; top: [[groupOfShapes.top]]px; width:  [[groupOfShapes.width]]px; height: [[groupOfShapes.height]]px;">
      <div id="nw" class="scale corner"></div>
      <div id="ne" class="scale corner"></div>
      <div id="sw" class="scale corner"></div>
      <div id="se" class="scale corner"></div>
      <div id="w" class="scale"></div>
      <div id="n" class="scale"></div>
      <div id="s" class="scale"></div>
      <div id="e" class="scale"></div>
      <div id="move"></div>
      <div id="rotate"></div>

      <div id="cornerhelp" class="help">Hold "shift" to scale symmetrically.</div>
      <!--<div id="rotatehelp" class="help">Hold "shift" to snap to nearest 30 deg.</div>-->
      <!--<div id="rotatehelp" class="help">Hold "shift" to rotate the elements individually.</div>-->
    </div>
    <group-of-shapes id="ghost" originals="[[infos]]"></group-of-shapes>
    <group-of-shapes id="ghostCopy" originals="[[visualCopy]]"></group-of-shapes>
  </template>

  <script>
    class DroppadItemMarker extends Polymer.Element {
      static get is() {
        return "droppad-item-marker";
      }

      static get config() {
        return {
          properties: {
            items: Array,
            infos: {
              type: Array,
              computed: "_getInfos(items)"
            },
            groupOfShapes: {
              type: Object,
              computed: "_itemsChanged(items, factor)"
            },
            heldkeys: Array,
            p2p: PointToPoint,
            factor: {
              type: Number,
              value: 40
            }
          }
        }
      }

      _getInfos(items) {
        if (!items || items.length == 0)
          return null;
        return items.map(el => el.info);
      }

      _itemsChanged(items, factor) {
        if (!items || items.length == 0)
          return null;
        let dims = {};
        for (let item of items) {
          let next = item.info.getBoundingRect(factor);
          dims.left = Math.min(dims.left || Number.MAX_VALUE, next.left);
          dims.top = Math.min(dims.top || Number.MAX_VALUE, next.top);
          dims.right = Math.max(dims.right || -Number.MAX_VALUE, next.right);
          dims.bottom = Math.max(dims.bottom || -Number.MAX_VALUE, next.bottom);
        }
        dims.width = dims.right - dims.left;
        dims.height = dims.bottom - dims.top;
        return dims;
      }

      connectedCallback() {
        this.$.marker.addEventListener("pointerdown", this._pointerDown.bind(this));
        this.pointermoveListener = this._pointerMove.bind(this);
        this.pointerupListener = this._pointerUp.bind(this);
        this._copyMoverListener = this._copyMover.bind(this);
        this._copyPlacerListener = this._copyPlacer.bind(this);
      }

      _pointerDown(e) {
        this.addEventListener("pointermove", this.pointermoveListener);
        this.addEventListener("pointerup", this.pointerupListener);
        this.setPointerCapture(e.pointerId);
        DroppadItemMarker._cancelPropDefault(e);
        this.action = this.setMoveAction(e, this.heldKeys);
        this.groupCenter = DroppadItemMarker.getScreenCenter(this.$.marker);
        this.start = {x: e.clientX, y: e.clientY};
        this.startAngle = Math.atan2(this.start.y - this.groupCenter.y, this.start.x - this.groupCenter.x);
        this.$.ghost.start();
      }

      _pointerUp(e) {
        this.dispatchEvent(new CustomEvent("changed", {detail: this.$.ghost.end()}));
        this.releasePointerCapture(e.pointerId);
        this.removeEventListener("pointerup", this.pointerupListener);
        this.removeEventListener("pointermove", this.pointermoveListener);
        DroppadItemMarker._cancelPropDefault(e);
        this._refreshItems();
      }

      //att! The setTimout(func, 0) makes the notifyPath("items") wait until Polymer has updated the selected items so that
      //     the groupOfShapes and its bounding box is updated with the new position info, and not the current one in the objects..
      //     This is a cascading problem..
      //todo this is a hack..
      _refreshItems() {
        setTimeout(function () {
          this.notifyPath("items");
        }.bind(this), 0);
      }

      _pointerMove(e) {
        DroppadItemMarker._cancelPropDefault(e);
        let xMove = this.p2p.addZoom(e.clientX - this.start.x);
        let yMove = this.p2p.addZoom(e.clientY - this.start.y);
        let percentX = xMove / this.groupOfShapes.width;
        let percentY = yMove / this.groupOfShapes.height;
        let angle = Math.atan2(e.clientY - this.groupCenter.y, e.clientX - this.groupCenter.x);
        //snap  start
        if (Math.abs(xMove) < 6 && Math.abs(yMove) < 6)
          xMove = yMove = 0;
        else if (this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"])
          xMove = yMove;
        //snap  end
        switch (this.action.method) {
          case "scale":
            return this.$.ghost.scaleDirection(xMove, yMove,percentX,percentY, this.action.direction);
          case "rotate":
            return this.$.ghost.rotate(angle - this.startAngle);
          case "move":
            return this.$.ghost.move(xMove, yMove);
        }
      }

      _copyMover(e){
        DroppadItemMarker._cancelPropDefault(e);
        let xMove = this.p2p.addZoom(e.clientX - this.copyCenter.x);
        let yMove = this.p2p.addZoom(e.clientY - this.copyCenter.y);
        this.$.ghostCopy.move(xMove, yMove);
      }

      _copyPlacer(e){
        this.parentNode.removeEventListener("pointermove", this._copyMoverListener);
        this.parentNode.removeEventListener("pointerdown", this._copyPlacerListener);
        this.dispatchEvent(new CustomEvent("new-shapes", {detail: this.$.ghostCopy.end()}));
        this.set("visualCopy", null);
        this.set("copyCenter", null);
      }

      static _cancelPropDefault(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      setMoveAction(e, heldKeys) {
        let direction = e.target.id;
        let action = "move"; //default action is move
        if (e.target.classList.contains("scale") || heldKeys["KeyE"])
          action = "scale";
        else if (e.target.id == "rotate" || heldKeys["KeyR"])
          action = "rotate";
        else if (e.target.id == "move")
          action = "move";
        return {method: action, direction: direction};
      }

      mirror() {
        let infos = this.infos.map(el => el.mirror());
        this.dispatchEvent(new CustomEvent("changed", {detail: infos}));
        this._refreshItems();
      }

      center() {
        let infos = this.infos.map(el => el.center());
        this.dispatchEvent(new CustomEvent("changed", {detail: infos}));
        this._refreshItems();
      }

      zDown() {
        let infos = this.infos.map(el => el.zDown());
        this.dispatchEvent(new CustomEvent("changed", {detail: infos}));
        this._refreshItems();
      }

      zUp() {
        let infos = this.infos.map(el => el.zUp());
        this.dispatchEvent(new CustomEvent("changed", {detail: infos}));
        this._refreshItems();
      }

      copy() {
        this.hiddenCopy = this.infos.map(el => el.makeCopy(0,0));
        this.copyCenter = DroppadItemMarker.getScreenCenter(this.$.marker);
      }

      paste() {
        this.set("visualCopy", this.hiddenCopy);
        this.$.ghostCopy.start();
        this.parentNode.addEventListener("pointermove", this._copyMoverListener);
        this.parentNode.addEventListener("pointerdown", this._copyPlacerListener);
      }

      abort() {
        //todo make a function that aborts changes while altering or copying.
      }

      static getScreenCenter(elem) {
        const box = elem.getBoundingClientRect();
        return {x: box.left + box.width / 2, y: box.top + box.height / 2};
      }
    }
    customElements.define(DroppadItemMarker.is, DroppadItemMarker);
  </script>
</dom-module>