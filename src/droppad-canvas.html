<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        width: 100vw;
        height: 100vh;
      }

      #crossX, #crossY, #pastePosition {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #crossX {
        height: 50%;
        width: 100%;
        border-bottom: 1px dashed lightgray;
      }

      #crossY {
        width: 50%;
        height: 100%;
        border-right: 1px dashed lightgray;
      }

      #pastePosition {
        margin-top: 50vh;
        margin-left: 50vw;
        width: 7px;
        height: 7px;
        border-right: 2px dotted red;
        border-bottom: 2px dotted red;
      }

    </style>
    <iron-selector id="dropSelector" on-click="singleSelect" selectable="shape-info" selected-attribute="data-selected"
                   selected-values="{{selectedDropsNum}}" selected-items="{{selectedDrops}}" multi>
      <slot></slot>
    </iron-selector>
    <div id="crossX"></div>
    <div id="crossY"></div>
    <div id="pastePosition" style$="top: [[position.1]]px; left: [[position.0]]px"></div>
  </template>

  <script>
    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            selectedDropsNum:Array,
            selectedDrops: {
              type: Array,
              notify: true,
              reflectToAttribute: true
            }
          }
        }
      }

      connectedCallback() {
        this.addEventListener("click", this._singleClick.bind(this));
        this.addEventListener("dblclick", this._doubleClick.bind(this));
        window.addEventListener("keydown", this._registerKey.bind(this));
      }

      _registerKey(e) {
        if (e.code === "Escape")
          this.deSelect();
        else if (e.code === "KeyD")
          this._deleteElem();
        else if (e.code === "KeyC")
          this.copiedShapes = this.selectedDrops.slice();
        else if (e.code === "KeyV") {
          for (let i = 0; i < this.copiedShapes.length; i++)
            this._addShape(this.copiedShapes[i].info);
        }
        //        if (e.code === "Equal" || e.code === "Minus")
//          this._changeZ(e.code);
      }

      _deleteElem() {
        this.dispatchEvent(new CustomEvent("delete", {detail: this.selectedDrops}));
        this.deSelect();
      }

      //this is a fix of the lack of shift+click in the multi iron selector.
      singleSelect(e){
        //skip no selected
        if (!this.selectedDropsNum || this.selectedDropsNum.length == 0)
          return;
        //use normal behaviour when shift is held down
        if (e.shiftKey)
          return;
        this.deSelect();
        //somehow this is enough, the iron selector looks to wait till last until it updates its selectedVALUES (not items)
        //todo here we need to check if it is a single element that is selected and that we are clicking and deselecting
        //todo here we can add the deselection of all when we are clicking on the background
      }

      deSelect() {
        this.selectedDropsNum = [];
        this.notifyPath("selectedDrops");
      }

//      _changeZ(key) {
//        if (key === "Equal") {
//          let node = this.$.shapeSelector.selected;
//          node.style.zIndex = node.style.zIndex ? Number(node.style.zIndex) + 1 : 1;
//        } else if (key === "Minus") {
//          let node = this.$.shapeSelector.selected;
//          if (node.style.zIndex < 1) {
//            let nodes = this.$.shapeSelector.querySelectorAll("shape-info");
//            for (let i = 0; i < nodes.length; i++) {
//              nodes[i].style.zIndex = Number(nodes[i].style.zIndex) + 1;
//            }
//            node.style.zIndex = Number(node.style.zIndex) - 1;
//          } else {
//            node.style.zIndex = node.style.zIndex ? Number(node.style.zIndex) - 1 : 0;
//          }
//        }
//
//        let nodes = this.$.shapeSelector.querySelectorAll("shape-info");
//        for (let i = 0; i < this.letters.length; i++) {
//          this.letters[i].zIndex = nodes[i].style.zIndex;
//        }
//        this.notifyPath("letters");
//      }

      _addShape(info) {
        this._makeShape(info.makeCopy(this.position[0], this.position[1]));
      };

      _singleClick(e) {
        this.position = [e.x - window.innerWidth / 2, e.y - window.innerHeight / 2];
      }

      _doubleClick(e) {
        this._makeShape(new ShapeInfoObject(this.position[0], this.position[1]));
      }

      _makeShape(shapeInfoObj){
        this.dispatchEvent(new CustomEvent("new", {detail: shapeInfoObj}));
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>