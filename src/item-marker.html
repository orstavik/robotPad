<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="group-of-shapes.html">

<dom-module id="item-marker">
  <template>
    <style>
      :host {
        display: block;
      }
      div {
        position: absolute;
      }
      #marker {
        position: absolute;
        box-sizing: border-box;
        top: 0;
        left: 0;
        border: 1px dotted grey;
      }
      #marker div {
        z-index: 10000;
      }
      .scale {
        width: 6px;
        height: 6px;
        background-color: lightgrey;
        border: 1px solid grey;
      }
      #nw {
        top: -4px;
        left: -4px;
      }
      #ne {
        top: -4px;
        right: -4px;
      }
      #sw {
        bottom: -4px;
        left: -4px;
      }
      #se {
        bottom: -4px;
        right: -4px;
      }
      #w {
        top: calc(50% - 4px);
        left: -4px;
        border-radius: 50% 0 0 50%;
      }
      #e {
        top: calc(50% - 4px);
        right: -4px;
        border-radius: 0 50% 50% 0;
      }
      #s {
        bottom: -4px;
        left: calc(50% - 4px);
        border-radius: 0 0 50% 50%;
      }
      #n {
        top: -4px;
        left: calc(50% - 4px);
        border-radius: 50% 50% 0 0;
      }
      #marker #move {
        bottom: -16px;
        right: -16px;
        width: 12px;
        height: 12px;
        transform: rotate(45deg);
        background: url(../images/move.png);
        background-size: contain;
      }
      #marker #rotate {
        top: -20px;
        right: -20px;
        width: 16px;
        height: 16px;
        background: url(../images/rotate.png);
        background-size: contain;
      }
      #ne:hover { cursor: nesw-resize; }
      #sw:hover { cursor: nesw-resize; }
      #nw:hover { cursor: nwse-resize; }
      #se:hover { cursor: nwse-resize; }
      #e:hover { cursor: ew-resize; }
      #w:hover { cursor: ew-resize; }
      #n:hover { cursor: ns-resize; }
      #s:hover { cursor: ns-resize; }
      #rotate:hover { cursor: ns-resize; }
      #move:hover { cursor: move; }
      #marker:hover { cursor: move; }
      /*.nw { transform-origin: 100% 100%; }*/
      /*.se { transform-origin: 0 0; }*/
      /*.ne { transform-origin: 0 100%; }*/
      /*.sw { transform-origin: 100% 0; }*/
      /*.s { transform-origin: 50% 0; }*/
      /*.n { transform-origin: 50% 100%; }*/
      /*.e { transform-origin: 0 50%; }*/
      /*.w { transform-origin: 100% 50%; }*/

    </style>
    <div id="marker" hidden$="[[!box]]" class$="[[direction]]" style$="
         left: [[box.left]]px;
         top: [[box.top]]px;
         width:  [[box.width]]px;
         height: [[box.height]]px;
         [[matrix]]">
      <div id="nw" class="scale corner"></div>
      <div id="ne" class="scale corner"></div>
      <div id="sw" class="scale corner"></div>
      <div id="se" class="scale corner"></div>
      <div id="w" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="n" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="s" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="e" class="scale" hidden$="[[!box.isSingle]]"></div>
      <div id="move"></div>
      <div id="rotate"></div>
    </div>
  </template>

  <script>
    class ItemMarker extends Polymer.Element {
      static get is() {
        return "item-marker";
      }

      static get config() {
        return {
          properties: {
            p2p: PointToPoint,
            box: Object,
            action: String,
            direction: String,
            changes: Object,
            matrix: {
              type: String,
              computed: "_makeMatrix(changes, box)"
            },
          }
        }
      }

      /**
       *
       * Adds the "normal third row of the matrix 0,0,1 turning the css matrix into a 3x3 matrix.
       *
       * Then do a normal dot multiplication.
       *
       * [
       *   a00, a01, a02,
       *   a10, a11, a12,
       *   a20, a21, a22,
       * ]
       *   *
       * [
       *   b00, b01, b02,
       *   b10, b11, b12,
       *   b20, b21, b22,
       * ]
       *   =
       *
       **/
//      multiplyMatrices (a, b) {
//        let a00 = a[0], a01 = a[2], a02 = a[4],
//            a10 = a[1], a11 = a[3], a12 = a[5],
//            a20 = 0, a21 = 0, a22 = 1;
//
//        let b00 = b[0], b01 = b[2], b02 = b[4],
//            b10 = b[1], b11 = b[3], b12 = b[5],
//            b20 = 0, b21 = 0, b22 = 1;
//
//        var result = [];
//        result[0] = b00*a00 + b01*a10 + b02*a20;
//        result[1] = b00*a01 + b01*a11 + b02*a21;
//        result[2] = b00*a02 + b01*a12 + b02*a22;
//
//        result[3] = b10*a00 + b11*a10 + b22*a20;
//        result[4] = b10*a01 + b11*a11 + b22*a21;
//        result[5] = b10*a02 + b11*a12 + b22*a22;
//
//        result[6] = b20*a00 + b21*a10 + b22*a20;
//        result[7] = b20*a01 + b21*a11 + b22*a21;
//        result[8] = b20*a02 + b21*a12 + b22*a22;
//        return [
//          result[0],
//          result[3],
//          result[1],
//          result[4],
//          result[2],
//          result[5]
//        ];
//      }

      multiMatrixTom(A, B) {
        A = [
          [A[0], A[2], A[4]],
          [A[1], A[3], A[5]],
          [0,0,1]
        ];
        B = [
          [B[0], B[2], B[4]],
          [B[1], B[3], B[5]],
          [0,0,1]
        ];
        let arr = [];
        for (let i = 0; i < A.length; i++) {
          arr.push([]);
          for (let j = 0; j < B[0].length; j++) {
            arr[i][j] = 0;
          }
        }
        for (let ai = 0; ai < A.length; ai++) {
          for (let bj = 0; bj < B[0].length; bj++) {
            for (let aj = 0; aj < A[0].length; aj++) {
              for (let bi = 0; bi < B.length; bi++) {
                if (aj === bi) {
                  arr[ai][bj] += A[ai][aj] * B[bi][bj];
                }
              }
            }
          }
        }
        return [arr[0][0],arr[1][0],arr[0][1], arr[1][1],arr[0][2],arr[1][2] ];
      }


      _makeMatrix(changes, box) {
        changes = changes || {};
        box = box || {};

        let rad2 = box.angle || 0;
        let startMatrix = [
          Math.cos(rad2),
          Math.sin(rad2),
          -1 * Math.sin(rad2),
          Math.cos(rad2),
          0,
          0];

        rad2 = (changes.angle || 0);
        let w2 = 1 + (changes.percentX || 0);
        let h2 = 1 + (changes.percentY || 0);
        let x2 = changes.xMove || 0;
        let y2 = changes.yMove || 0;
        const matrixWithoutStart = [
          w2 * Math.cos(rad2),
          w2 * Math.sin(rad2),
          -h2 * Math.sin(rad2),
          h2 * Math.cos(rad2),
          x2,
          y2];
//        let testMatrix = this.multiplyMatrices(matrixWithoutStart, startMatrix);
        let mergedMatrices = this.multiMatrixTom(matrixWithoutStart,Â startMatrix);

//        let rad = (box.angle || 0) + (changes.angle || 0);
//        let w = 1 + (changes.percentX || 0);
//        let h = 1 + (changes.percentY || 0);
//        let x = changes.xMove || 0;
//        let y = changes.yMove || 0;
//        const matrix = [
//          w * Math.cos(rad),
//          w * Math.sin(rad),
//          -h * Math.sin(rad),
//          h * Math.cos(rad),
//          x,
//          y];
//
//        console.log("__test__");
//        console.log(matrix);
//        console.log(testMatrix);
//        console.log(mergedMatrices);
//        console.log("____");

        return "transform: matrix(" + mergedMatrices.join(',') + ");";
//        return "transform: matrix(" + matrix.join(',') + ");";
      }

      connectedCallback() {
        this.$.marker.addEventListener("pointerdown", this._pointerDown.bind(this));
        this.pointermoveListener = this._pointerMove.bind(this);
        this.pointerupListener = this._pointerUp.bind(this);
      }

      _pointerDown(e) {
        ItemMarker._cancelPropDefault(e);
        this.setPointerCapture(e.pointerId);
        this.addEventListener("pointermove", this.pointermoveListener);
        this.addEventListener("pointerup", this.pointerupListener);
        this.start = this.p2p.calcLogicPoint(e.clientX, e.clientY);
        this.startAngle = ItemMarker.calcAngle(this.box.center, this.start);
        this.set("direction", e.target.id);
        this.set("action", this.setMoveAction(e));
        this.set("changes", null);
        this.dispatchEvent(new CustomEvent("track-start", {composed: true, bubbles: true, detail: this.action}));
      }

      _pointerMove(e) {
        ItemMarker._cancelPropDefault(e);
        let newPos = this.p2p.calcLogicPoint(e.clientX, e.clientY);
//        newPos = this.doSnappingOnPointer(newPos, this.start);
        let ms = this.calculateEventData(this.start, newPos, this.box, this.startAngle, this.action, this.direction);
        ms.direction = this.direction;
        ms.action = this.action;
        ms.box = this.box;
        this.set("changes", ms);
        this.dispatchEvent(new CustomEvent("track-move", {detail: ms, composed: true, bubbles: true}));
      }

      calculateEventData(start, newPos, box, startAngle, action, direction) {
        if (action == "scale") {
          if (direction.indexOf("n") < 0 && direction.indexOf("s") < 0)
            newPos.y = start.y;
          if (direction.indexOf("e") < 0 && direction.indexOf("w") < 0)
            newPos.x = start.x;

          let ms = {
            percentX: (newPos.x - start.x) / box.width,
            percentY: (newPos.y - start.y) / box.height
          };
          ms.yMove = box.height/2 * ms.percentY;
          ms.xMove = box.width/2 * ms.percentX;

          if (direction.indexOf("n") >= 0)
            ms.percentY *= -1;
          if (direction.indexOf("w") >= 0)
            ms.percentX *= -1;
          return ms;
        }
        if (action == "rotate")
          return {angle: ItemMarker.calcAngle(box.center, newPos) - startAngle};
        //if (this.action == "move")
        return {xMove: newPos.x - start.x, yMove: newPos.y - start.y};
      }

      _pointerUp(e) {
        ItemMarker._cancelPropDefault(e);
        this.releasePointerCapture(e.pointerId);
        this.removeEventListener("pointerup", this.pointerupListener);
        this.removeEventListener("pointermove", this.pointermoveListener);
        this.dispatchEvent(new CustomEvent("track-end", {composed: true, bubbles: true}));
        this.set("changes", null);
        this.set("action", null);
        this.set("direction", null);
      }

      static _cancelPropDefault(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      getLogicalCenter() {
        return this.box.center;
      }

      setMoveAction(e) {
        if (this.heldKeys["KeyR"])
          return "rotate";
        if (this.heldKeys["KeyE"])
          return "scale";
        if (e.target.classList.contains("scale"))
          return "scale";
        if (e.target.id == "rotate")
          return "rotate";
        return "move";
      }

      doSnappingOnPointer(point, start) {
        if (Math.abs(start.x - point.x) < 6 && Math.abs(start.y - point.y) < 6)
          return start;
        if (this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"] || !this.box.isSingle)
          return {x: point.y, y: point.y};
        return point;
      }

      static calcAngle(center, satelite) {
        return Math.atan2(satelite.y - center.y, satelite.x - center.x);
      }
    }
    customElements.define(ItemMarker.is, ItemMarker);
  </script>
</dom-module>