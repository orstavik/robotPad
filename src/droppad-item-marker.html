<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="group-of-shapes.html">

<dom-module id="droppad-item-marker">
  <template>
    <style>
      :host {
        display: block;
      }

      div {
        position: absolute;
      }

      #marker {
        box-sizing: border-box;
        top: 0;
        left: 0;
        border: 1px dotted grey;
      }

      #marker div {
        z-index: 10000;
      }

      .scale {
        width: 6px;
        height: 6px;
        background-color: lightgrey;
        border: 1px solid grey;
      }

      #nw {
        top: -4px;
        left: -4px;
      }

      #ne {
        top: -4px;
        right: -4px;
      }

      #sw {
        bottom: -4px;
        left: -4px;
      }

      #se {
        bottom: -4px;
        right: -4px;
      }

      #w {
        top: calc(50% - 4px);
        left: -4px;
        border-radius: 50% 0 0 50%;
      }

      #e {
        top: calc(50% - 4px);
        right: -4px;
        border-radius: 0 50% 50% 0;
      }

      #s {
        bottom: -4px;
        left: calc(50% - 4px);
        border-radius: 0 0 50% 50%;
      }

      #n {
        top: -4px;
        left: calc(50% - 4px);
        border-radius: 50% 50% 0 0;
      }

      #marker #move {
        top: calc(50% - 6px);
        left: calc(50% - 6px);
        width: 12px;
        height: 12px;
        transform: rotate(45deg);
        background: url(../images/move.png);
        background-size: contain;
      }

      #marker #rotate {
        top: -20px;
        right: -20px;
        width: 16px;
        height: 16px;
        background: url(../images/rotate.png);
        background-size: contain;
      }

      #ne:hover {
        cursor: nesw-resize;
      }

      #sw:hover {
        cursor: nesw-resize;
      }

      #nw:hover {
        cursor: nwse-resize;
      }

      #se:hover {
        cursor: nwse-resize;
      }

      #e:hover {
        cursor: ew-resize;
      }

      #w:hover {
        cursor: ew-resize;
      }

      #n:hover {
        cursor: ns-resize;
      }

      #s:hover {
        cursor: ns-resize;
      }

      #rotate:hover {
        cursor: ns-resize;
      }

      #move:hover {
        cursor: move;
      }

      #marker:hover {
        cursor: move;
      }

    </style>
    <div id="marker" hidden$="[[!groupOfShapes]]"
         style$="
         left: [[groupOfShapes.left]]px;
         top: [[groupOfShapes.top]]px;
         width:  [[groupOfShapes.width]]px;
         height: [[groupOfShapes.height]]px;
         [[cssMatrix]]">
      <div id="nw" class="scale corner"></div>
      <div id="ne" class="scale corner"></div>
      <div id="sw" class="scale corner"></div>
      <div id="se" class="scale corner"></div>
      <template is="dom-if" if="[[groupOfShapes.isSingle]]">
        <div id="w" class="scale"></div>
        <div id="n" class="scale"></div>
        <div id="s" class="scale"></div>
        <div id="e" class="scale"></div>
      </template>
      <div id="move"></div>
      <div id="rotate"></div>
    </div>
  </template>

  <script>
    class SquareBox {

      constructor(boxes, p2p){
        this.p2p = p2p;
        this.isSingle = boxes.length == 1;
        for (let next of boxes) {
          this.left = Math.min(this.left || Number.MAX_VALUE, next.left);
          this.top = Math.min(this.top || Number.MAX_VALUE, next.top);
          this.right = Math.max(this.right || -Number.MAX_VALUE, next.right);
          this.bottom = Math.max(this.bottom || -Number.MAX_VALUE, next.bottom);
        }
        this.left = p2p.toLogicalX(this.left);
        this.right= p2p.toLogicalX(this.right);
        this.top= p2p.toLogicalY(this.top);
        this.bottom= p2p.toLogicalY(this.bottom);

        this.width = this.right - this.left;
        this.height = this.bottom - this.top;
        this.center = {};
        this.center.x = this.left + this.width / 2;
        this.center.y = this.top + this.height / 2;
      }
    }

    class DroppadItemMarker extends Polymer.Element {
      static get is() {
        return "droppad-item-marker";
      }

      static get config() {
        return {
          properties: {
            items: {
              type: Array,
              value: function () {
                return [];
              }
            },
            p2p: PointToPoint,
            groupOfShapes: {
              type: Object,
              computed: "_calcRectangle(items, p2p)"
            },
            action: String,
            direction: String,
            startAngle2: {
              type: Number,
              computed: "_calcStartAngle(items)"
            },
            changes: {
              type: Object,
              value: null
            },
            cssMatrix: {
              type: String,
              computed: "_changeStyle(changes, action, direction, startAngle2)"
            }
          }
        }
      }

      _changeStyle(changes, action, direction, startAngle2) {
        if (!changes)
          return startAngle2 ? "transform: rotate(" + startAngle2 + "rad);" : "";
        if (action == "rotate")
          return "transform: rotate(" + (startAngle2 + changes.angle ) + "rad);";
        if (action == "move")
          return "transform: translate(" + changes.xMove + "px, " + changes.yMove + "px) rotate(" + startAngle2 + "rad);";
        if (action != "scale")
          return "";
        return DroppadItemMarker.textToCssTransformOrigin(direction) +
            "transform: scaleX(" + (1 + changes.percentX) + ") scaleY(" + (1 + changes.percentY) + ") rotate(" + startAngle2 + "rad);";
      }

      static textToCssTransformOrigin(direction){
        if (direction == "nw")
          return "transform-origin: 100% 100%; ";
        if (direction == "se")
          return "transform-origin: 0% 0%; ";
        if (direction == "ne")
          return "transform-origin: 0% 100%; ";
        if (direction == "sw")
          return "transform-origin: 100% 0%; ";
        if (direction == "s")
          return "transform-origin: 50% 0%; ";
        if (direction == "n")
          return "transform-origin: 50% 100%; ";
        if (direction == "e")
          return "transform-origin: 0% 50%; ";
        if (direction == "w")
          return "transform-origin: 100% 50%; ";
        return "";
      }

      _calcStartAngle(items){
        return items && items.length == 1 ? items[0].info.angle : 0;
      }

      _calcRectangle(items, p2p) {
        if (!items || items.length == 0)
          return null;
        let boxes = [];
        for (let el of items)
          boxes.push(el.getBoundingClientRect());
        return new SquareBox(boxes, p2p);
      }

      connectedCallback() {
        this.$.marker.addEventListener("pointerdown", this._pointerDown.bind(this));
        this.pointermoveListener = this._pointerMove.bind(this);
        this.pointerupListener = this._pointerUp.bind(this);
      }

      _pointerDown(e) {
        DroppadItemMarker._cancelPropDefault(e);
        this.setPointerCapture(e.pointerId);
        this.addEventListener("pointermove", this.pointermoveListener);
        this.addEventListener("pointerup", this.pointerupListener);
        this.start = this.p2p.calcLogicPoint(e.clientX, e.clientY);
        this.set("startAngle" ,DroppadItemMarker.calcAngle(this.groupOfShapes.center, this.start));
        this.set("direction", e.target.id);
        this.set("action", this.setMoveAction(e));
        this.set("changes", null);
        this.dispatchEvent(new CustomEvent("track-start", {composed: true, bubbles: true, detail: this.action}));
      }

      _pointerMove(e) {
        DroppadItemMarker._cancelPropDefault(e);
        const logicPointPos = this.p2p.calcLogicPoint(e.clientX, e.clientY);
        let ms = this.calculateTrackMovements(logicPointPos);
        ms.direction = this.direction;
        ms.action = this.action;
        ms.box = this.groupOfShapes;
        this.doSnapping(ms);
        this.set("changes", ms);
        this.dispatchEvent(new CustomEvent("track-move", {detail: ms, composed: true, bubbles: true}));
      }

      _pointerUp(e) {
        DroppadItemMarker._cancelPropDefault(e);
        this.releasePointerCapture(e.pointerId);
        this.removeEventListener("pointerup", this.pointerupListener);
        this.removeEventListener("pointermove", this.pointermoveListener);
        this.dispatchEvent(new CustomEvent("track-end", {composed: true, bubbles: true}));
        this.set("changes", null);
        this.set("action", null);
        this.set("direction", null);
      }

      static _cancelPropDefault(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      getLogicalCenter() {
        return this.groupOfShapes.center;
      }

      setMoveAction(e) {
        if (this.heldKeys["KeyR"])
          return "rotate";
        if (this.heldKeys["KeyE"])
          return "scale";
        if (e.target.classList.contains("scale"))
          return "scale";
        if (e.target.id == "rotate")
          return "rotate";
        return "move";
      }

      calculateTrackMovements(logicPointPos) {
        const movX = logicPointPos.x - this.start.x;
        const movY = logicPointPos.y - this.start.y;
        const scaleX = movX / this.groupOfShapes.width;
        const scaleY = movY / this.groupOfShapes.height;
        const angle = DroppadItemMarker.calcAngle(this.groupOfShapes.center, logicPointPos);
        return {
          xMove: movX,
          yMove: movY,
          percentX: scaleX,
          percentY: scaleY,
          angle: angle - this.startAngle,
        };
      }

      //todo this could use some work..
      doSnapping(ms) {
        if (this.direction.indexOf("n") >= 0)
          ms.percentY= -ms.percentY;
        if (this.direction.indexOf("w") >= 0)
          ms.percentX = -ms.percentX;
        if (this.direction.indexOf("n") < 0 && this.direction.indexOf("s") < 0)
          ms.percentY= 0;
        if (this.direction.indexOf("e") < 0 && this.direction.indexOf("w") < 0)
          ms.percentX = 0;
        if (Math.abs(ms.xMove) < 6 && Math.abs(ms.yMove) < 6)
          ms.xMove = ms.yMove = 0;
        if (this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"]) {
          ms.xMove = ms.yMove;
          ms.percentX = ms.percentY;
        }
        if (ms.action == "scale" && !this.groupOfShapes.isSingle)
          ms.percentX = ms.percentY;
      }

      static calcAngle(center, satelite){
        return Math.atan2(satelite.y - center.y, satelite.x - center.x);
      }
    }
    customElements.define(DroppadItemMarker.is, DroppadItemMarker);
  </script>
</dom-module>