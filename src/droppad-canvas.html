<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="droppad-selector.html">
<link rel="import" href="droppad-canvas-canvas.html">
<link rel="import" href="droppad-item-marker.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }

      drop-shape[data-selected] {
        box-shadow: 0 0 3px 0px black;
      }

    </style>
    <droppad-canvas-canvas id="canvas" p2p="{{p2p}}" on-new-shape="_newShape" on-deselect="_deselectAll">
      <droppad-selector id="dropSelector" selected-elements="{{selectedDrops}}">
        <template is="dom-repeat" items="[[drops]]">
          <drop-shape id="drop[[item.number]]" info="[[item]]"></drop-shape>
        </template>
      </droppad-selector>
      <droppad-item-marker id="square" items="[[selectedDrops]]" p2p="[[p2p]]"
                           on-track-start="_startMovingMarker"
                           on-track-move="_movingMarker"
                           on-track-end="_stopMovingMarker"></droppad-item-marker>
      <group-of-shapes id="ghost" originals="[[selectedInfos]]"></group-of-shapes>
      <group-of-shapes id="ghostCopy" originals="[[visualCopy]]"></group-of-shapes>
    </droppad-canvas-canvas>
  </template>

  <script>
    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            drops: {
              type: Array,
              notify: true
            },
            selectedDrops: {
              type: Array,
              notify: true
            },
            selectedInfos: {
              type: Array,
              computed: "_setSelectedInfos(selectedDrops)"
            },
            heldKeys: Array,
            history: {
              type: Array,
              value: function () {
                return [];
              },
              notify: true
            }
          }
        }
      }

      connectedCallback(){
        this._copyMoverListener = this._copyMover.bind(this);
        this._copyPlacerListener = this._copyPlacer.bind(this);
      }

      _setSelectedInfos(elems) {
        return elems.map(item => item.info);
      }

      _startMovingMarker(e) {
        let action = e.detail;
        if (this.heldKeys["KeyR"])
          action.method = "rotate";
        else if (this.heldKeys["KeyE"])
          action.method = "scale";
        this.$.ghost.start(action);
      }

      _movingMarker(e) {
        let ms = e.detail;
        this.doSnapping(ms);
        switch (this.$.ghost.action.method) {
          case "scale":
            return this.$.ghost.scaleDirection(ms.xMove, ms.yMove, ms.percentX, ms.percentY, this.$.ghost.action.direction);
          case "rotate":
            return this.$.ghost.rotate(ms.angle);
          case "move":
            return this.$.ghost.move(ms.xMove, ms.yMove);
        }
      }

      doSnapping(ms) {
        if (Math.abs(ms.xMove) < 6 && Math.abs(ms.yMove) < 6)
          ms.xMove = ms.yMove = 0;
        else if (this.heldKeys["ShiftLeft"] || this.heldKeys["ShiftRight"])
          ms.xMove = ms.yMove;
      }

      _stopMovingMarker(e) {
        this.replaceChanges(this.$.ghost.end());
      }

      _copyMover(e){
        DroppadItemMarker._cancelPropDefault(e);
        let xMove = this.p2p.addZoom(e.clientX - this.copyCenter.x);
        let yMove = this.p2p.addZoom(e.clientY - this.copyCenter.y);
        this.$.ghostCopy.move(xMove, yMove);
      }

      _copyPlacer(e){
        this.removeEventListener("pointermove", this._copyMoverListener);
        this.removeEventListener("pointerdown", this._copyPlacerListener);
        this.$.dropSelector.deselectAll();
        this._addElements(this.$.ghostCopy.end());
        this.set("visualCopy", null);
        this.set("copyCenter", null);
      }

      copy() {
        this.hiddenCopy = this.selectedInfos.map(el => el.makeCopy());
        this.copyCenter = this.$.square.getCenter();
      }

      paste() {
        this.set("visualCopy", this.hiddenCopy);
        this.$.ghostCopy.start("move");
        this.addEventListener("pointermove", this._copyMoverListener);
        this.addEventListener("pointerdown", this._copyPlacerListener);
      }

      handleKeyPress(e) {
        if (e.code === "Escape")
          this.$.dropSelector.deselectAll(); // also do this.$.square.abort();
        else if (e.code === "Digit0" && this.heldKeys["ControlLeft"])
          this.$.canvas.reset();
        else if (e.code === "KeyD")
          this._deleteElem();
        else if (e.code === "KeyC")
          this.copy();
        else if (e.code === "KeyV")
          this.paste();
        else if (e.code == "KeyM")
          this.replaceChanges(this.selectedInfos.map(info => info.mirror()));
        else if (e.code == "KeyN")
          this.replaceChanges(this.selectedInfos.map(info => info.center()));
        else if (e.code == "PageUp")
          this.replaceChanges(this.selectedInfos.map(info => info.zUp()));
        else if (e.code == "PageDown")
          this.replaceChanges(this.selectedInfos.map(info => info.zDown()));
      }

      addStyleToSelected(styleName) {
        this.replaceChanges(this.selectedInfos.map(info => info.setStyle(styleName)));
      }

      updateShape(id, value) {
        this.$.dropSelector.deselectAll();
        this.select(id);
        this.replaceChanges(this.selectedInfos.map(el => el.update(value)));
      }

      select(id) {
        this.$.dropSelector.select(this.shadowRoot.querySelector("#drop" + id));
      }

      _deselectAll() {
        this.$.dropSelector.deselectAll();
      }

      _newShape(e) {
        let shape = new ShapeInfoObject(e.detail.x, e.detail.y);
        this._addElements([shape]);
        if (!e.shiftKey)
          this.$.dropSelector.deselectAll();
        setTimeout(function () {
          this.select(shape.number);
        }.bind(this), 0);
      }

      loadSketch(drops) {
        this.set("drops", drops);
      }

      //att! The setTimout(func, 0) makes the notifyPath("selection") wait until Polymer has updated the selected items so that
      //     the groupOfShapes and its bounding box is updated with the new position info, and not the current one in the objects..
      //     This is a cascading problem..
      replaceChanges(changedCopies) {
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.replaceEqualNumber(this.drops, changedCopies));
        setTimeout(function () {
          this.notifyPath("selectedDrops");
        }.bind(this), 0);
      }

      _deleteElem() {
        this.history.push(this.drops);
        this.set("drops", this.drops.filter(item => this.selectedInfos.indexOf(item) == -1)); //Immutable filter is immutable, returns a new array
        this.$.dropSelector.deselectAll();    //todo maybe move this as a listener to changes on drops in the selector?
      }

      _addElements(newShapes) {
        this.history.push(this.drops);
        this.set("drops", this.drops.concat(newShapes));//Immutable .concat() makes a new array object instance
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>