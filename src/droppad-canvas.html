<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        width: 100vw;
        height: 100vh;
      }

      drop-shape[data-selected] {
        box-shadow: 0 0 3px 0px black;
      }

      #crossX, #crossY, #pastePosition {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #crossX {
        height: 50%;
        width: 100%;
        border-bottom: 1px dashed lightgray;
      }

      #crossY {
        width: 50%;
        height: 100%;
        border-right: 1px dashed lightgray;
      }

      #pastePosition {
        margin-top: 50vh;
        margin-left: 50vw;
        width: 7px;
        height: 7px;
        border-right: 2px dotted red;
        border-bottom: 2px dotted red;
      }

    </style>
    History: <input type="range" min="0" max="100" value="0" id="h" on-input="setHistory"/> <br>
    <iron-selector id="dropSelector" on-click="singleSelect" selectable="drop-shape" selected-attribute="data-selected"
                   selected-values="{{selectedDropsNum}}" selected-items="{{selectedDrops}}" multi>
      <template is="dom-repeat" items="[[drops]]">
        <drop-shape id="drop[[item.number]]" info="[[item]]"></drop-shape>
      </template>
    </iron-selector>
    <div id="crossX"></div>
    <div id="crossY"></div>
    <div id="pastePosition" style$="top: [[position.1]]px; left: [[position.0]]px"></div>
  </template>

  <script>
    class ShapeInfoObject {
      constructor(x, y) {
        this.number = ShapeInfoObject.generateId();
        this.style = "no";
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.angle = 0;
        this.zIndex = 1000;
        this.centered = true;
      }

      makeCopy(x, y) {
        let c = this.clone();
        c.number = ShapeInfoObject.generateId();
        c.x += x;
        c.y += y;
        return c;
      }

      clone() {
        return Object.assign(new ShapeInfoObject(0, 0), this);
      }

      //2*PI = 360gr
      rotate(deg){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.angle = (2 * Math.PI + (c.angle + deg / 50)) % (2 * Math.PI);
        return c;
      }

      move(x, y) {
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.x += x;
        c.y += y;
        return c;
      }

      scaleSquare(y){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.w = c.h = c.h + y/20;
        return c;
      }

      scaleRestrict(y){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        const divis = c.w / c.h;
        c.w += y/30*divis;
        c.h += y/30;
        return c;
      }

      scaleFree(x, y) {
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        let cos = Math.cos(c.angle);
        let sin = Math.sin(c.angle);
        let nx = cos * x + sin * y;
        let ny = cos * y - sin * x;
        c.w += nx / 20;
        c.h -= ny / 20;
        return c;
      }

      mirror(){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.w *= -1;
        return c;
      }
      center(){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.centered =! c.centered;
        return c;
      }
      zUp(){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.zIndex += 1;
        return c;
      }
      zDown(){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.zIndex -= 1;
        return c;
      }
      setStyle(styleName){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        c.style = styleName;
        return c;
      }

      getAngle(){
        let angle = this.angle;
        if (this.centered)
          angle+=45/180*Math.PI;
        if (this.style.startsWith("tone"))
          angle = 0;
        return angle;
      }

      update(value){
        let c = Object.assign(new ShapeInfoObject(0,0), this);
        Object.assign(c, value);
        return c;
      }

      cssMatrix(){
        let angle = this.getAngle();
        let matrix = [
          this.w * Math.cos(angle),
          this.w * Math.sin(angle),
          -this.h * Math.sin(angle),
          this.h * Math.cos(angle),
          this.x,
          this.y];
        return "matrix(" + matrix.join(',') + ")";
      }

      static generateId(){
        return ShapeInfoObject.__sessionID++;
      }
    }
    ShapeInfoObject.__sessionID = 0;

    class ImmutableArrayFunctions {
      static push(array, obj) {
        array = array.slice();
        array.push(obj);
        return array;
      }
      static filter(array, numbers) {
        return array.filter(function (item) {
          return numbers.indexOf(item.number) == -1;
        });
      }
      static alter(array, numbers, func, arg1, arg2){
        array = array.map(function (item) {
          if (numbers.indexOf(item.number) == -1)
            return item;
          return func.call(item, arg1, arg2);
        });
        return array;
      }

      //todo, breaking the alter method in two.
      //todo, First, we do a .map on all the items that makes a new array object, with clones for the selected objects. The parallell structure is in place.
      //todo, Second, then run over all the selected objects in the new array, and alter their position.
      //todo, this strategy is 10 times (!!) faster than alter1. Without removing the complexities inside ShapeInfoObject.
      static alter2(array, numbers, func, arg1, arg2){
        let toBeAltered = [];
        array = array.map(function (item) {
          if (numbers.indexOf(item.number) == -1)
            return item;
          item = item.clone();
          toBeAltered.push(item);
          return item;
        });
        toBeAltered = toBeAltered.map(function(item){
          item = func.call(item, arg1, arg2);
          console.log(item);
          return item;
        });
        return array;
      }

      //todo it looks like Stringify is 2x as slow as parse(?!).
      static testJSONstringifyParseSpeed() {
        let start = new Date().getTime();
        console.log("test1: " + start);
        let ar = [];
        for (var i = 0; i < 100000; i++) {
          ar[i] = JSON.stringify(start);
        }
        let stop = new Date().getTime();
        console.log("test1: " + (stop - start));
        start = stop;
        console.log("test2: " + start);
        for (var j = 0; j < 100000; j++) {
          ar[100000 + j] = JSON.parse(ar[j]);
        }
        stop = new Date().getTime();
        console.log("test2: " + (stop - start));
      }

      static testSpeed(count) {
        let start = new Date().getTime();
        console.log("speed 1: " + start);
        let ar = [];
        for (var i = 0; i < count; i++) {
          ar[i] = new ShapeInfoObject(i,i);
        }
        let stop = new Date().getTime();
        console.log("speed 1: " + (stop - start));

        let number = Math.floor(count/10);
        let selected = [0, number*1, number*3, number*5, number*7, number*2, number*4, number*6, number*8, number*9];

        start = stop;
        console.log("speed 2: " + start);
        ar = ImmutableArrayFunctions.alter2(ar, selected, ShapeInfoObject.prototype.scaleFree, -10, 10);
        stop = new Date().getTime();
        console.log("speed 2: " + (stop - start));
      }
    }

    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            drops: {
              type: Array,
              notify: true
            },
            selectedDropsNum: Array,
            selectedDrops: {
              type: Array,
              notify: true,
              reflectToAttribute: true
            },
            selectedInfos:{
              type: Array,
              computed: "_fromDrops(selectedDrops)"
            },
            heldKeys: Array,
            history:{
              type: Array,
              value: function(){
                return [];
              }
            }
          }
        }
      }
      _fromDrops(selected){
        return selected.map(function(drop){return drop.info.number;});
      }
      setHistory(e){
        if (e.target.valueAsNumber >= this.history.length) e.target.valueAsNumber = this.history.length;
        this.drops = this.history[e.target.valueAsNumber];
        this.notifyPath("drops");
      }
      connectedCallback() {
        this.addEventListener("click", this._singleClick.bind(this));
        window.addEventListener("keydown", this._registerKey.bind(this));
        window.addEventListener("mousemove", this.mouseMove.bind(this));
//        ImmutableArrayFunctions.testJSONstringifyParseSpeed();
        ImmutableArrayFunctions.testSpeed(100000);
// making 100000 objects and then moving 10 of them takes only 44+24ms on this machine. The problem is then only the painting.
      }

      _registerKey(e) {
        if (e.code === "Escape")
          this.deSelect();
        else if (e.code === "KeyD"){
          this._deleteElem();
          this.deSelect();
        } else if (e.code === "KeyC")
          this.copiedShapes = this.selectedDrops.slice();
        else if (e.code === "KeyV") {
          for (let i = 0; i < this.copiedShapes.length; i++) {
            this._addElem(this.copiedShapes[i].info.makeCopy(this.position[0], this.position[1]));
          }
        }
        else if (e.code == "KeyM")
          this.alterSelected(ShapeInfoObject.prototype.mirror);
        else if (e.code == "KeyN")
          this.alterSelected(ShapeInfoObject.prototype.center);
        else if (e.code == "PageUp")
          this.alterSelected(ShapeInfoObject.prototype.zUp);
        else if (e.code == "PageDown")
          this.alterSelected(ShapeInfoObject.prototype.zDown);
      }

      mouseMove(e) {
        if (e.which != 1)
          return;
        if (!this.selectedDrops)
          return;
        if (this.heldKeys["KeyE"] && this.heldKeys["KeyW"])
          this.alterSelected(ShapeInfoObject.prototype.scaleRestrict, e.movementY);
        else if (this.heldKeys["KeyE"] && this.heldKeys["KeyR"])
          this.alterSelected(ShapeInfoObject.prototype.scaleSquare, e.movementY);
        else if (this.heldKeys["KeyE"])
          this.alterSelected(ShapeInfoObject.prototype.scaleFree, e.movementX, e.movementY);
        else if (this.heldKeys["KeyR"])
          this.alterSelected(ShapeInfoObject.prototype.rotate, e.movementY);
        else
          this.alterSelected(ShapeInfoObject.prototype.move, e.movementX, e.movementY);
      }

      addStyleToSelected(styleName){
        this.alterSelected(ShapeInfoObject.prototype.setStyle, styleName);
      }

      updateShape(id, value){
        this.deSelect();
        this.select(id);
        this.alterSelected(ShapeInfoObject.prototype.update, value);
      }

      //this is a fix of the lack of shift+click in the multi iron selector.
      singleSelect(e) {
        //skip no selected
        if (!this.selectedDropsNum || this.selectedDropsNum.length == 0)
          return;
        //use normal behaviour when shift is held down
        if (e.shiftKey)
          return;
        //one element selected, and that is the one clicked, it should be deselected by the default logic
        if (this.selectedDropsNum.length == 1 && e.target.parentElement == this.selectedDrops[0])
          return;
        this.deSelect();
        //somehow this is enough, the iron selector looks to wait till last until it updates its selectedVALUES (not items)
      }

      deSelect() {
        this.selectedDropsNum = [];
        this.notifyPath("selectedDropsNum");
      }
      select(id){
        this.shadowRoot.querySelector("#drop"+id).click();
      }

      _singleClick(e) {
        this.position = [e.x - window.innerWidth / 2, e.y - window.innerHeight / 2];
        if (e.ctrlKey) {
          let shape = new ShapeInfoObject(this.position[0], this.position[1]);
          this._addElem(shape);
          this.deSelect();
          setTimeout(function(){    //hack so polymer will have time to update itself.
            this.select(shape.number);
          }.bind(this));
          return;
        }
        if (e.path[0] == this) {
          this.deSelect();
          return;
        }
      }

      loadSketch(drops){
        this.set("drops", drops);
      }

      alterSelected(func, arg1, arg2){
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.alter(this.drops, this.selectedInfos, func, arg1, arg2));
      }

      _deleteElem() {
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.filter(this.drops, this.selectedInfos));
      }

      _addElem(shapeInfoObj) {
        this.history.push(this.drops);
        this.set("drops", ImmutableArrayFunctions.push(this.drops, shapeInfoObj));
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>