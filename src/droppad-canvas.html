<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="drop-shape.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">

<dom-module id="droppad-canvas">
  <template>
    <style>
      :host {
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 0;
        width: 100vw;
        height: 100vh;
      }

      drop-shape[data-selected] {
        box-shadow: 0 0 3px 0px black;
      }

      #crossX, #crossY, #pastePosition {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #crossX {
        height: 50%;
        width: 100%;
        border-bottom: 1px dashed lightgray;
      }

      #crossY {
        width: 50%;
        height: 100%;
        border-right: 1px dashed lightgray;
      }

      #pastePosition {
        margin-top: 50vh;
        margin-left: 50vw;
        width: 7px;
        height: 7px;
        border-right: 2px dotted red;
        border-bottom: 2px dotted red;
      }

    </style>
    <iron-selector id="dropSelector" on-click="singleSelect" selectable="drop-shape" selected-attribute="data-selected"
                   selected-values="{{selectedDropsNum}}" selected-items="{{selectedDrops}}" multi>
      <template is="dom-repeat" items="[[drops]]">
        <drop-shape info="[[item]]"></drop-shape>
      </template>
    </iron-selector>
    <div id="crossX"></div>
    <div id="crossY"></div>
    <div id="pastePosition" style$="top: [[position.1]]px; left: [[position.0]]px"></div>
  </template>

  <script>
    class ShapeInfoObject {
      constructor(x, y) {
        this.number = ShapeInfoObject.generateId();
        this.style = "no";
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.angle = 0;
        this.zIndex = 1000;
        this.centered = true;
      }

      makeCopy(x, y) {
        let c = this.clone();
        c.number = ShapeInfoObject.generateId();
        c.x += x;
        c.y += y;
        return c;
      }

      //2*PI = 360gr
      rotate(deg){
        this.angle = (2 * Math.PI + (this.angle + deg / 50)) % (2 * Math.PI);
      }

      move(x, y) {
        this.x += x;
        this.y += y;
      }

      scaleSquare(y){
        this.w = this.h = this.h + y/20;
      }

      scaleRestrict(y){
        const divis = this.w / this.h;
        this.w += y/30*divis;
        this.h += y/30;
      }

      scaleFree(x, y) {
        let cos = Math.cos(this.angle);
        let sin = Math.sin(this.angle);
        let nx = cos * x + sin * y;
        let ny = cos * y - sin * x;
        this.w += nx / 20;
        this.h -= ny / 20;
      }

      mirror(){
        this.w *= -1;
      }
      center(){
        this.centered =! this.centered;
      }
      zUp(){
        this.zIndex += 1;
      }
      zDown(){
        this.zIndex -= 1;
      }
      setStyle(styleName){
        this.style = styleName;
      }

      update(value){
        Object.assign(this, value);
      }

      cssMatrix(){
        let angle = this.angle;
        if (this.centered)
          angle+=45/180*Math.PI;
        if (this.style.startsWith("tone"))
          angle = 0;
        let matrix = [
          this.w * Math.cos(angle),
          this.w * Math.sin(angle),
          -this.h * Math.sin(angle),
          this.h * Math.cos(angle),
          this.x,
          this.y];
        return "matrix(" + matrix.join(',') + ")";
      }

      static generateId(){
        return ShapeInfoObject.__sessionID++;
      }
    }
    ShapeInfoObject.__sessionID = 0;

    class DroppadCanvas extends Polymer.Element {
      static get is() {
        return "droppad-canvas";
      }

      static get config() {
        return {
          properties: {
            drops: {
              type: Array,
              notify: true
            },
            selectedDropsNum: Array,
            selectedDrops: {
              type: Array,
              notify: true,
              reflectToAttribute: true
            },
            heldKeys: Array
          }
        }
      }

      connectedCallback() {
        this.addEventListener("click", this._singleClick.bind(this));
        window.addEventListener("keydown", this._registerKey.bind(this));
        window.addEventListener("mousemove", this.mouseMove.bind(this));
      }

      _registerKey(e) {
        if (e.code === "Escape")
          this.deSelect();
        else if (e.code === "KeyD")
          this._deleteElem();
        else if (e.code === "KeyC")
          this.copiedShapes = this.selectedDrops.slice();
        else if (e.code === "KeyV") {
          for (let i = 0; i < this.copiedShapes.length; i++) {
            this._makeShape(this.copiedShapes[i].info.makeCopy(this.position[0], this.position[1]));
          }
        }
        else if (e.code == "KeyM")
          this.selectedDrops.map(function (shape) {
            shape.info.mirror()
          });
        else if (e.code == "KeyN")
          this.selectedDrops.map(function (shape) {
            shape.info.center();
          });
        else if (e.code == "PageUp")
          this.selectedDrops.map(function (shape) {
            shape.info.zUp();
          });
        else if (e.code == "PageDown")
          this.selectedDrops.map(function (shape) {
            shape.info.zDown();
          });
        this.notifyPath("drops", this.drops);
      }

      _deleteElem() {
        let selects = this.selectedDrops;
        this.drops = this.drops.filter(function (item) {
          let i = selects.find(function (select) {
            return select.info == item;
          });
          return !i;
        });
        this.notifyPath("drops", this.drops);
        this.deSelect();
      }

      mouseMove(e) {
        if (e.which != 1)
          return;
        if (!this.selectedDrops)
          return;
        if (this.heldKeys["KeyE"] && this.heldKeys["KeyW"])
          this.selectedDrops.map(function (shape) { shape.info.scaleRestrict(e.movementY); });
        else if (this.heldKeys["KeyE"] && this.heldKeys["KeyR"])
          this.selectedDrops.map(function (shape) { shape.info.scaleSquare(e.movementY); });
        else if (this.heldKeys["KeyE"])
          this.selectedDrops.map(function (shape) { shape.info.scaleFree(e.movementX, e.movementY); });
        else if (this.heldKeys["KeyR"])
          this.selectedDrops.map(function (shape) { shape.info.rotate(e.movementY); });
        else
          this.selectedDrops.map(function (shape) { shape.info.move(e.movementX, e.movementY); });
        this.notifyPath("drops", this.drops);
      }

      //this is a fix of the lack of shift+click in the multi iron selector.
      singleSelect(e) {
        //skip no selected
        if (!this.selectedDropsNum || this.selectedDropsNum.length == 0)
          return;
        //use normal behaviour when shift is held down
        if (e.shiftKey)
          return;
        //one element selected, and that is the one clicked, it should be deselected by the default logic
        if (this.selectedDropsNum.length == 1 && e.target.parentElement == this.selectedDrops[0])
          return;
        this.deSelect();
        //somehow this is enough, the iron selector looks to wait till last until it updates its selectedVALUES (not items)
      }

      deSelect() {
        this.selectedDropsNum = [];
        this.notifyPath("selectedDropsNum");
      }

      _singleClick(e) {
        this.position = [e.x - window.innerWidth / 2, e.y - window.innerHeight / 2];
        if (e.ctrlKey) {
          this._makeShape(new ShapeInfoObject(this.position[0], this.position[1]));
          //todo make this one selected
          return;
        }
        if (e.path[0] == this) {
          this.deSelect();
          return;
        }
      }

      loadSketch(drops){
        this.set("drops", drops);
      }

      updateShape(id, value){
        let target = this.drops.find(function(drop){
          return drop.number == id;
        });
        target.update(value);
        this.notifyPath("drops", this.drops);
      }

      addStyleToSelected(styleName){
        for (let drop of this.selectedDrops)
          drop.info.setStyle(styleName);
        this.notifyPath("drops", this.drops);
      }

      //todo, here we have the making of new history
      _makeShape(shapeInfoObj) {
        this.drops.push(shapeInfoObj);
        this.notifyPath("drops", this.drops);
      }
    }
    customElements.define(DroppadCanvas.is, DroppadCanvas);
  </script>
</dom-module>